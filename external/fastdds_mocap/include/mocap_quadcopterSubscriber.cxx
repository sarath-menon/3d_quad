// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file mocap_quadcopterSubscriber.cpp
 * This file contains the implementation of the subscriber functions.
 *
 * This file was generated by the tool fastcdrgen.
 */

#include <fastdds/dds/domain/DomainParticipantFactory.hpp>
#include <fastdds/dds/subscriber/DataReader.hpp>
#include <fastdds/dds/subscriber/SampleInfo.hpp>
#include <fastdds/dds/subscriber/Subscriber.hpp>
#include <fastdds/dds/subscriber/qos/DataReaderQos.hpp>

#include "mocap_quadcopterPubSubTypes.h"
#include "mocap_quadcopterSubscriber.h"

using namespace eprosima::fastdds::dds;

mocap_quadcopterSubscriber::mocap_quadcopterSubscriber()
    : participant_(nullptr), subscriber_(nullptr), topic_(nullptr),
      reader_(nullptr), type_(new mocap_quadcopterPubSubType()) {}

mocap_quadcopterSubscriber::~mocap_quadcopterSubscriber() {
  if (reader_ != nullptr) {
    subscriber_->delete_datareader(reader_);
  }
  if (topic_ != nullptr) {
    participant_->delete_topic(topic_);
  }
  if (subscriber_ != nullptr) {
    participant_->delete_subscriber(subscriber_);
  }
  DomainParticipantFactory::get_instance()->delete_participant(participant_);
}

bool mocap_quadcopterSubscriber::init() {
  // CREATE THE PARTICIPANT
  DomainParticipantQos pqos;
  pqos.name("Participant_sub");
  participant_ =
      DomainParticipantFactory::get_instance()->create_participant(0, pqos);
  if (participant_ == nullptr) {
    return false;
  }

  // REGISTER THE TYPE
  type_.register_type(participant_);

  // CREATE THE SUBSCRIBER
  subscriber_ =
      participant_->create_subscriber(SUBSCRIBER_QOS_DEFAULT, nullptr);
  if (subscriber_ == nullptr) {
    return false;
  }

  // CREATE THE TOPIC
  topic_ = participant_->create_topic("mocap_quadcopterTopic",
                                      type_.get_type_name(), TOPIC_QOS_DEFAULT);
  if (topic_ == nullptr) {
    return false;
  }

  // CREATE THE READER
  DataReaderQos rqos = DATAREADER_QOS_DEFAULT;
  rqos.reliability().kind = RELIABLE_RELIABILITY_QOS;
  reader_ = subscriber_->create_datareader(topic_, rqos, &listener_);
  if (reader_ == nullptr) {
    return false;
  }

  return true;
}

void mocap_quadcopterSubscriber::SubListener::on_subscription_matched(
    DataReader *, const SubscriptionMatchedStatus &info) {
  if (info.current_count_change == 1) {
    matched = info.total_count;
    std::cout << "Subscriber matched." << std::endl;
  } else if (info.current_count_change == -1) {
    matched = info.total_count;
    std::cout << "Subscriber unmatched." << std::endl;
  } else {
    std::cout << info.current_count_change
              << " is not a valid value for SubscriptionMatchedStatus current "
                 "count change"
              << std::endl;
  }
  // Set subscriber count
  mocap_sub::matched = matched;
}

void mocap_quadcopterSubscriber::SubListener::on_data_available(
    eprosima::fastdds::dds::DataReader *reader) {
  // Take data
  mocap_quadcopter st;
  eprosima::fastdds::dds::SampleInfo info;

  if (reader->take_next_sample(&st, &info) == ReturnCode_t::RETCODE_OK) {
    if (info.valid_data) {
      // Print your structure data here.
      ++samples;
      mocap_sub::new_data = true;

      // // Set subscriber count
      // mocap_sub::matched = matched;

      // std::cout << "\nSample received, count=" << samples << std::endl;
      // std::cout << "Index=" << st.index() << std::endl;
      // std::cout << "Object Name:" << st.object_name() << std::endl;

      mocap_sub::object_name = st.object_name();
      mocap_sub::index = st.index();

      mocap_sub::position[0] = st.position().at(0) / 1000;
      mocap_sub::position[1] = st.position().at(1) / 1000;
      mocap_sub::position[2] = st.position().at(2) / 1000;

      mocap_sub::orientation[0] = st.orientation_quaternion().at(0);
      mocap_sub::orientation[1] = st.orientation_quaternion().at(1);
      mocap_sub::orientation[2] = st.orientation_quaternion().at(2);
      mocap_sub::orientation[3] = st.orientation_quaternion().at(3);

      mocap_sub::orientation_euler[0] = st.orientation_euler().at(0);
      mocap_sub::orientation_euler[1] = st.orientation_euler().at(1);
      mocap_sub::orientation_euler[2] = st.orientation_euler().at(2);

      mocap_sub::latency = st.delay();

      // Sleep for 1 millisecond
      std::this_thread::sleep_for(std::chrono::milliseconds(1));
    }
  }
}
